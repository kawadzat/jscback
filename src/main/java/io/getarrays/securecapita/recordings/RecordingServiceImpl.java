package io.getarrays.securecapita.recordings;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.servlet.mvc.method.annotation.StreamingResponseBody;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

/**
 * Service implementation for Recording entity operations.
 * 
 * @author Generated
 * @version 1.0
 * @since 2025
 */
@Service
@RequiredArgsConstructor
@Slf4j
@Transactional
public class RecordingServiceImpl implements RecordingService {

    private final RecordingRepository recordingRepository;
    
    // Constructor is generated by @RequiredArgsConstructor

    @Override
    public Recording create(Recording recording) {
        log.info("Creating new recording with case details: {}", recording.getCaseDetails());
        
        // Set default status if not provided
        if (recording.getStatus() == null) {
            recording.setStatus(RecordingStatus.RECORDING);
        }
        
        return recordingRepository.save(recording);
    }

    @Override
    public Recording update(Long id, Recording recording) {
        log.info("Updating recording with id: {}", id);
        
        Recording existingRecording = getById(id);
        
        // Update fields
        existingRecording.setCaseDetails(recording.getCaseDetails());
        existingRecording.setJudge(recording.getJudge());
        existingRecording.setStartTime(recording.getStartTime());
        existingRecording.setEndTime(recording.getEndTime());
        existingRecording.setDuration(recording.getDuration());
        existingRecording.setStatus(recording.getStatus());
        existingRecording.setFileSize(recording.getFileSize());
        existingRecording.setFileName(recording.getFileName());
        existingRecording.setFilePath(recording.getFilePath());
        
        return recordingRepository.save(existingRecording);
    }

    @Override
    @Transactional(readOnly = true)
    public Recording getById(Long id) {
        log.info("Fetching recording with id: {}", id);
        return recordingRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Recording not found with id: " + id));
    }

    @Override
    @Transactional(readOnly = true)
    public List<Recording> getAll() {
        log.info("Fetching all recordings");
        return recordingRepository.findAll();
    }

    @Override
    public void delete(Long id) {
        log.info("Deleting recording with id: {}", id);
        Recording recording = getById(id);
        recordingRepository.delete(recording);
    }

    @Override
    public Recording updateStatus(Long id, RecordingStatus status) {
        log.info("Updating status of recording {} to {}", id, status);
        
        Recording recording = getById(id);
        recording.setStatus(status);
        
        return recordingRepository.save(recording);
    }

    @Override
    public List<Recording> bulkUpdateStatus(List<Long> ids, RecordingStatus status) {
        log.info("Bulk updating status of {} recordings to {}", ids.size(), status);
        
        List<Recording> recordings = recordingRepository.findAllById(ids);
        recordings.forEach(recording -> recording.setStatus(status));
        
        return recordingRepository.saveAll(recordings);
    }

    @Override
    @Transactional(readOnly = true)
    public List<Recording> getByStatus(RecordingStatus status) {
        log.info("Fetching recordings with status: {}", status);
        return recordingRepository.findByStatus(status);
    }

    @Override
    public Recording startRecording(StartRecordingRequest request) {
        log.info("Starting microphone recording for case: {}", request.getCaseDetails());
        
        Recording recording = Recording.builder()
                .caseDetails(request.getCaseDetails())
                .judge(request.getJudge())
                .startTime(LocalDateTime.now())
                .status(RecordingStatus.RECORDING)
                .build();
        
        // Set default duration to 0 (will be updated when stopped)
        recording.setDuration(0);
        
        return recordingRepository.save(recording);
    }

    @Override
    public Recording stopRecording(Long id) {
        log.info("Stopping recording with id: {}", id);
        
        Recording recording = getById(id);
        
        if (recording.getStatus() != RecordingStatus.RECORDING) {
            throw new RuntimeException("Recording is not currently active");
        }
        
        LocalDateTime endTime = LocalDateTime.now();
        recording.setEndTime(endTime);
        
        // Calculate duration in seconds
        if (recording.getStartTime() != null) {
            long durationSeconds = java.time.Duration.between(recording.getStartTime(), endTime).getSeconds();
            recording.setDuration((int) durationSeconds);
        }
        
        recording.setStatus(RecordingStatus.COMPLETED);
        
        return recordingRepository.save(recording);
    }

    @Override
    public Recording uploadAudioFile(Long id, MultipartFile audioFile) {
        log.info("Uploading audio file for recording id: {}", id);
        
        Recording recording = getById(id);
        
        if (audioFile.isEmpty()) {
            throw new RuntimeException("Audio file is empty");
        }
        
        try {
            // Create upload directory if it doesn't exist
            String uploadDir = "recordings/audio/";
            Path uploadPath = Paths.get(uploadDir);
            if (!Files.exists(uploadPath)) {
                Files.createDirectories(uploadPath);
            }
            
            // Generate unique filename
            String originalFilename = audioFile.getOriginalFilename();
            String fileExtension = originalFilename != null ? 
                originalFilename.substring(originalFilename.lastIndexOf(".")) : ".wav";
            String uniqueFilename = "recording_" + id + "_" + UUID.randomUUID().toString() + fileExtension;
            
            // Save file
            Path filePath = uploadPath.resolve(uniqueFilename);
            Files.copy(audioFile.getInputStream(), filePath);
            
            // Update recording with file information
            recording.setFileName(uniqueFilename);
            recording.setFilePath(filePath.toString());
            recording.setFileSize(audioFile.getSize());
            
            // Update status to backed if file is uploaded
            if (recording.getStatus() == RecordingStatus.COMPLETED) {
                recording.setStatus(RecordingStatus.BACKED);
            }
            
            return recordingRepository.save(recording);
            
        } catch (IOException e) {
            log.error("Error uploading audio file: {}", e.getMessage());
            throw new RuntimeException("Failed to upload audio file: " + e.getMessage());
        }
    }

    @Override
    @Transactional(readOnly = true)
    public RecordingStatus getRecordingStatus(Long id) {
        log.info("Getting recording status for id: {}", id);
        Recording recording = getById(id);
        return recording.getStatus();
    }

    @Override
    public ResponseEntity<byte[]> downloadAudioFile(Long id) {
        log.info("Downloading audio file for recording id: {}", id);
        
        Recording recording = getById(id);
        
        if (recording.getFilePath() == null || recording.getFileName() == null) {
            return ResponseEntity.notFound().build();
        }
        
        try {
            Path filePath = Paths.get(recording.getFilePath());
            
            if (!Files.exists(filePath)) {
                log.error("Audio file not found: {}", filePath);
                return ResponseEntity.notFound().build();
            }
            
            byte[] fileContent = Files.readAllBytes(filePath);
            
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(getMediaType(recording.getFileName()));
            headers.setContentLength(fileContent.length);
            headers.set(HttpHeaders.CONTENT_DISPOSITION, 
                "attachment; filename=\"" + recording.getFileName() + "\"");
            
            return ResponseEntity.ok()
                    .headers(headers)
                    .body(fileContent);
                    
        } catch (IOException e) {
            log.error("Error downloading audio file: {}", e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @Override
    public ResponseEntity<StreamingResponseBody> streamAudioFile(Long id) {
        log.info("Streaming audio file for recording id: {}", id);
        
        Recording recording = getById(id);
        
        if (recording.getFilePath() == null || recording.getFileName() == null) {
            return ResponseEntity.notFound().build();
        }
        
        try {
            Path filePath = Paths.get(recording.getFilePath());
            
            if (!Files.exists(filePath)) {
                log.error("Audio file not found: {}", filePath);
                return ResponseEntity.notFound().build();
            }
            
            StreamingResponseBody responseBody = outputStream -> {
                try (InputStream inputStream = Files.newInputStream(filePath)) {
                    byte[] buffer = new byte[8192];
                    int bytesRead;
                    while ((bytesRead = inputStream.read(buffer)) != -1) {
                        outputStream.write(buffer, 0, bytesRead);
                    }
                    outputStream.flush();
                } catch (IOException e) {
                    log.error("Error streaming audio file: {}", e.getMessage());
                }
            };
            
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(getMediaType(recording.getFileName()));
            headers.setContentLength(Files.size(filePath));
            headers.set(HttpHeaders.CONTENT_DISPOSITION, 
                "attachment; filename=\"" + recording.getFileName() + "\"");
            
            return ResponseEntity.ok()
                    .headers(headers)
                    .body(responseBody);
                    
        } catch (IOException e) {
            log.error("Error preparing audio stream: {}", e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @Override
    @Transactional(readOnly = true)
    public AudioDownloadInfo getDownloadInfo(Long id) {
        log.info("Getting download info for recording id: {}", id);
        
        Recording recording = getById(id);
        
        AudioDownloadInfo.AudioDownloadInfoBuilder builder = AudioDownloadInfo.builder()
                .recordingId(id)
                .fileName(recording.getFileName())
                .filePath(recording.getFilePath())
                .fileSize(recording.getFileSize())
                .mimeType(getMediaType(recording.getFileName()).toString())
                .downloadUrl("/api/v1/recording/" + id + "/download")
                .streamUrl("/api/v1/recording/" + id + "/stream")
                .caseDetails(recording.getCaseDetails())
                .judge(recording.getJudge())
                .duration(recording.getDuration())
                .status(recording.getStatus());
        
        // Check if file exists
        if (recording.getFilePath() != null) {
            try {
                Path filePath = Paths.get(recording.getFilePath());
                boolean fileExists = Files.exists(filePath);
                builder.fileExists(fileExists);
                
                if (fileExists) {
                    builder.lastModified(LocalDateTime.ofInstant(
                        Files.getLastModifiedTime(filePath).toInstant(),
                        java.time.ZoneId.systemDefault()
                    ));
                } else {
                    builder.errorMessage("Audio file not found on disk");
                }
            } catch (IOException e) {
                builder.fileExists(false)
                       .errorMessage("Error checking file: " + e.getMessage());
            }
        } else {
            builder.fileExists(false)
                   .errorMessage("No audio file uploaded for this recording");
        }
        
        return builder.build();
    }
    
    private MediaType getMediaType(String fileName) {
        if (fileName == null) {
            return MediaType.APPLICATION_OCTET_STREAM;
        }
        
        String extension = fileName.toLowerCase();
        if (extension.endsWith(".wav")) {
            return MediaType.valueOf("audio/wav");
        } else if (extension.endsWith(".mp3")) {
            return MediaType.valueOf("audio/mpeg");
        } else if (extension.endsWith(".m4a")) {
            return MediaType.valueOf("audio/mp4");
        } else if (extension.endsWith(".ogg")) {
            return MediaType.valueOf("audio/ogg");
        } else {
            return MediaType.APPLICATION_OCTET_STREAM;
        }
    }
}
